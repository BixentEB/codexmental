<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Syst√®me solaire 3D ‚Äì test</title>
<style>
  html,body{height:100%;margin:0;background:#030c16;overflow:hidden;font-family:system-ui}
  #hint{position:fixed;left:12px;top:12px;color:#9feaff;font-size:12px;opacity:.8}
</style>
</head>
<body>
<div id="hint">üñ±Ô∏è clic-gauche: tourner ¬∑ molette: zoom ¬∑ clic-droit: d√©placer</div>

<!-- ‚úÖ VERSION MODULES (chemins corrects) -->
<script type="module">
  import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
  import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';

  // Rendu
  const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0x06121e, 1);
  document.body.appendChild(renderer.domElement);

  // Sc√®ne + cam√©ra
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 2000);
  camera.position.set(0, 60, 140);

  // Contr√¥les (si import √©choue ‚áí rien ne s'affiche ; ici OK)
  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.minDistance = 30;
  controls.maxDistance = 400;

  // Lumi√®res (garantit qu‚Äôon ne voit pas noir)
  scene.add(new THREE.AmbientLight(0x88aacc, 0.5));
  const sunLight = new THREE.PointLight(0xffffff, 2.2, 0, 2);
  sunLight.position.set(0,0,0);
  scene.add(sunLight);

  // Soleil (auto-√©clair√©)
  const sun = new THREE.Mesh(
    new THREE.SphereGeometry(10, 48, 48),
    new THREE.MeshBasicMaterial({ color:0xffe07a })
  );
  scene.add(sun);

  // Halo du soleil
  const glow = new THREE.Sprite(new THREE.SpriteMaterial({
    map: (()=>{ const c=document.createElement('canvas'); c.width=c.height=256;
      const g=c.getContext('2d'); const grd=g.createRadialGradient(128,128,0,128,128,128);
      grd.addColorStop(0,'rgba(255,240,160,0.9)');
      grd.addColorStop(0.5,'rgba(255,200,80,0.25)');
      grd.addColorStop(1,'rgba(0,0,0,0)');
      g.fillStyle=grd; g.fillRect(0,0,256,256); const t=new THREE.CanvasTexture(c); t.needsUpdate=true; return t;})(),
    transparent:true, depthWrite:false
  }));
  glow.scale.set(70,70,1);
  scene.add(glow);

  // √âtoiles de fond
  {
    const starGeo = new THREE.BufferGeometry();
    const N = 2000, pos = new Float32Array(N*3);
    for(let i=0;i<N;i++){
      pos[i*3+0] = (Math.random()-0.5)*2000;
      pos[i*3+1] = (Math.random()-0.5)*2000;
      pos[i*3+2] = (Math.random()-0.5)*2000;
    }
    starGeo.setAttribute('position', new THREE.BufferAttribute(pos,3));
    const stars = new THREE.Points(starGeo, new THREE.PointsMaterial({ size:1, color:0xffffff }));
    scene.add(stars);
  }

  // Plan√®tes (rayon d‚Äôorbite r, taille size, vitesse speed)
  const planets = [];
  const data = [
    {name:'Mercure', r:16, size:1.1, speed:0.020, color:0x9aa7ff},
    {name:'V√©nus',   r:22, size:1.5, speed:0.015, color:0xffb36a},
    {name:'Terre',   r:30, size:1.7, speed:0.010, color:0x58d178},
    {name:'Mars',    r:38, size:1.3, speed:0.008, color:0xff6b4b},
    {name:'Jupiter', r:55, size:4.2, speed:0.005, color:0xf0b36e},
    {name:'Saturne', r:72, size:3.6, speed:0.004, color:0xdacc9d, ring:true},
    {name:'Uranus',  r:88, size:2.6, speed:0.003, color:0x79e6ff},
    {name:'Neptune', r:104,size:2.5, speed:0.002, color:0x4ca0ff},
  ];

  const orbitMat = new THREE.LineBasicMaterial({ color:0x00ffff, transparent:true, opacity:0.22 });
  data.forEach(p=>{
    const mesh = new THREE.Mesh(
      new THREE.SphereGeometry(p.size, 32, 32),
      new THREE.MeshStandardMaterial({ color:p.color, roughness:0.6, metalness:0.0 })
    );
    mesh.userData = { r:p.r, speed:p.speed, angle:Math.random()*Math.PI*2 };
    scene.add(mesh);
    planets.push(mesh);

    // Orbite
    const curve = new THREE.EllipseCurve(0,0,p.r,p.r);
    const pts = curve.getPoints(256).map(pt=>new THREE.Vector3(pt.x,0,pt.y));
    const geo = new THREE.BufferGeometry().setFromPoints(pts);
    const orbit = new THREE.LineLoop(geo, orbitMat);
    orbit.rotation.x = Math.PI/2;
    scene.add(orbit);

    // Anneau de Saturne (simple)
    if(p.ring){
      const ring = new THREE.Mesh(
        new THREE.RingGeometry(p.size*1.4, p.size*2.3, 64, 1),
        new THREE.MeshBasicMaterial({ color:0xded7b3, transparent:true, opacity:0.65, side:THREE.DoubleSide })
      );
      ring.rotation.x = Math.PI/2.6;
      mesh.add(ring);
    }
  });

  // Mini radar HUD (option d√©cor)
  const hud = document.createElement('canvas');
  hud.width = 160; hud.height = 160; hud.style.position='fixed';
  hud.style.left='50%'; hud.style.bottom='20px'; hud.style.transform='translateX(-50%)';
  hud.style.opacity='0.9';
  document.body.appendChild(hud);
  const hctx = hud.getContext('2d');

  let sweep = -Math.PI/2;
  function drawHUD(){
    const ctx = hctx, w=hud.width, h=hud.height, cx=w/2, cy=h/2, r=70;
    ctx.clearRect(0,0,w,h);
    ctx.strokeStyle='#33eaff'; ctx.globalAlpha=0.3;
    for(let i=1;i<=3;i++){ ctx.beginPath(); ctx.arc(cx,cy,(r*i/3),0,Math.PI*2); ctx.stroke(); }
    for(let i=0;i<8;i++){ const a=i*Math.PI/4; ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(cx+Math.cos(a)*r, cy+Math.sin(a)*r); ctx.stroke(); }
    // balayage
    ctx.globalAlpha=0.5; ctx.strokeStyle='#8fffff'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(cx+Math.cos(sweep)*r, cy+Math.sin(sweep)*r); ctx.stroke();
    ctx.globalAlpha=1;
  }

  // Animation
  function tick(){
    // orbites
    planets.forEach(p=>{
      p.userData.angle += p.userData.speed;
      p.position.set(Math.cos(p.userData.angle)*p.userData.r, 0, Math.sin(p.userData.angle)*p.userData.r);
    });
    // hud
    sweep += 0.05; drawHUD();

    controls.update();
    renderer.render(scene, camera);
    requestAnimationFrame(tick);
  }
  tick();

  // Resize
  window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>

<!-- ‚ùó Si vous voyez encore un √©cran noir, votre navigateur n'a peut-√™tre pas WebGL2 actif. Essayez un autre navigateur. -->
</body>
</html>
