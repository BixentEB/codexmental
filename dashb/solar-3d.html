<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Syst√®me solaire 3D ‚Äì robuste</title>
<style>
  html,body{height:100%;margin:0;background:#06121e;overflow:hidden}
  #hint{position:fixed;left:12px;top:10px;color:#9feaff;font:12px system-ui;opacity:.85}
  #warn{position:fixed;left:12px;top:28px;color:#ffa8a8;font:12px system-ui}
  canvas{display:block}
</style>
</head>
<body>
<div id="hint">üñ±Ô∏è gauche: tourner ¬∑ molette: zoom ¬∑ droit: d√©placer</div>
<div id="warn"></div>

<!-- Three UMD + Controls UMD (compatibles) -->
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js"></script>
<script>
(function(){
  // V√©rification WebGL
  let ok=false; try{const c=document.createElement('canvas'); ok=!!(c.getContext('webgl')||c.getContext('experimental-webgl'));}catch(e){}
  if(!ok){ document.getElementById('warn').textContent = "‚ö†Ô∏è WebGL indisponible (pilote/acc√©l√©ration mat√©rielle)."; return; }

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 2000);
  camera.position.set(0,60,140);

  const renderer = new THREE.WebGLRenderer({antialias:true, alpha:false});
  renderer.setSize(innerWidth, innerHeight);
  renderer.setPixelRatio(Math.min(devicePixelRatio,2));
  renderer.setClearColor(0x06121e,1);
  document.body.appendChild(renderer.domElement);

  // Contr√¥les (global THREE doit exister; avec UMD, oui)
  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.minDistance = 30;
  controls.maxDistance = 400;

  // Lumi√®res (√©vite l'√©cran trop sombre)
  scene.add(new THREE.AmbientLight(0x88aacc, 0.5));
  const sunLight = new THREE.PointLight(0xffffff, 2.2, 0, 2);
  scene.add(sunLight);

  // Soleil
  const sun = new THREE.Mesh(
    new THREE.SphereGeometry(10, 48, 48),
    new THREE.MeshBasicMaterial({ color:0xffe07a })
  );
  scene.add(sun);

  // Halo
  const texCanvas = document.createElement('canvas'); texCanvas.width = texCanvas.height = 256;
  const g = texCanvas.getContext('2d');
  const grd = g.createRadialGradient(128,128,0,128,128,128);
  grd.addColorStop(0,'rgba(255,240,160,0.9)');
  grd.addColorStop(0.5,'rgba(255,200,80,0.25)');
  grd.addColorStop(1,'rgba(0,0,0,0)');
  g.fillStyle=grd; g.fillRect(0,0,256,256);
  const glow = new THREE.Sprite(new THREE.SpriteMaterial({ map:new THREE.CanvasTexture(texCanvas), transparent:true, depthWrite:false }));
  glow.scale.set(70,70,1); scene.add(glow);

  // √âtoiles
  const starGeo = new THREE.BufferGeometry();
  const N=2000, arr=new Float32Array(N*3);
  for(let i=0;i<N;i++){ arr[i*3]=(Math.random()-0.5)*2000; arr[i*3+1]=(Math.random()-0.5)*2000; arr[i*3+2]=(Math.random()-0.5)*2000; }
  starGeo.setAttribute('position', new THREE.BufferAttribute(arr,3));
  scene.add(new THREE.Points(starGeo, new THREE.PointsMaterial({size:1,color:0xffffff})));

  // Plan√®tes
  const planets=[];
  const data=[
    {name:'Mercure', r:16, size:1.1, speed:0.020, color:0x9aa7ff},
    {name:'V√©nus',   r:22, size:1.5, speed:0.015, color:0xffb36a},
    {name:'Terre',   r:30, size:1.7, speed:0.010, color:0x58d178},
    {name:'Mars',    r:38, size:1.3, speed:0.008, color:0xff6b4b},
    {name:'Jupiter', r:55, size:4.2, speed:0.005, color:0xf0b36e},
    {name:'Saturne', r:72, size:3.6, speed:0.004, color:0xdacc9d, ring:true},
    {name:'Uranus',  r:88, size:2.6, speed:0.003, color:0x79e6ff},
    {name:'Neptune', r:104,size:2.5, speed:0x002, color:0x4ca0ff}
  ];
  const orbitMat=new THREE.LineBasicMaterial({color:0x00ffff,transparent:true,opacity:.22});
  data.forEach(p=>{
    const m=new THREE.Mesh(
      new THREE.SphereGeometry(p.size,32,32),
      new THREE.MeshStandardMaterial({color:p.color,roughness:.6,metalness:0})
    );
    m.userData={r:p.r,speed:(typeof p.speed==="number"?p.speed:0.002),angle:Math.random()*Math.PI*2};
    scene.add(m); planets.push(m);

    // orbite
    const curve=new THREE.EllipseCurve(0,0,p.r,p.r);
    const pts=curve.getPoints(256).map(pt=>new THREE.Vector3(pt.x,0,pt.y));
    const geo=new THREE.BufferGeometry().setFromPoints(pts);
    const line=new THREE.LineLoop(geo, orbitMat); line.rotation.x=Math.PI/2; scene.add(line);

    // anneau saturne
    if(p.ring){
      const ring=new THREE.Mesh(
        new THREE.RingGeometry(p.size*1.4,p.size*2.3,64,1),
        new THREE.MeshBasicMaterial({color:0xded7b3,transparent:true,opacity:.65,side:THREE.DoubleSide})
      );
      ring.rotation.x=Math.PI/2.6; m.add(ring);
    }
  });

  // Animation
  function loop(){
    for(const p of planets){
      p.userData.angle += p.userData.speed;
      p.position.set(Math.cos(p.userData.angle)*p.userData.r, 0, Math.sin(p.userData.angle)*p.userData.r);
    }
    controls.update();
    renderer.render(scene,camera);
    requestAnimationFrame(loop);
  }
  loop();

  addEventListener('resize', ()=>{
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });
})();
</script>
</body>
</html>
