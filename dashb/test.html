<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Système solaire 3D - Radar HUD</title>
  <style>
    body { margin:0; overflow:hidden; background:#000; }
    canvas { display:block; }
  </style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.157.0/examples/js/controls/OrbitControls.js"></script>
<script>
  // Scène
  const scene = new THREE.Scene();

  // Caméra
  const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0, 50, 120);

  // Rendu
  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Contrôles (rotation, zoom, inclinaison)
  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;

  // Lumière (soleil au centre)
  const light = new THREE.PointLight(0xffffff, 2, 500);
  scene.add(light);

  // Soleil
  const sunGeo = new THREE.SphereGeometry(10, 32, 32);
  const sunMat = new THREE.MeshBasicMaterial({color:0xffdd55});
  const sun = new THREE.Mesh(sunGeo, sunMat);
  scene.add(sun);

  // Planètes
  const planets = [];
  const planetData = [
    {r:15, size:1.2, speed:0.02, color:0x8899ff}, // Mercure
    {r:20, size:1.5, speed:0.015, color:0xff9933}, // Venus
    {r:28, size:1.6, speed:0.01, color:0x33cc33}, // Terre
    {r:36, size:1.4, speed:0.008, color:0xff3300}, // Mars
    {r:50, size:4, speed:0.005, color:0xffaa00}, // Jupiter
    {r:65, size:3, speed:0.004, color:0xcccc99}, // Saturne
    {r:80, size:2.5, speed:0.003, color:0x33ccff}, // Uranus
    {r:95, size:2.4, speed:0.002, color:0x3366ff}, // Neptune
  ];

  planetData.forEach(p=>{
    const geo = new THREE.SphereGeometry(p.size, 24, 24);
    const mat = new THREE.MeshStandardMaterial({color:p.color});
    const mesh = new THREE.Mesh(geo, mat);
    mesh.userData = {r:p.r, speed:p.speed, angle:Math.random()*Math.PI*2};
    scene.add(mesh);
    planets.push(mesh);

    // Orbite
    const curve = new THREE.EllipseCurve(0,0, p.r, p.r);
    const points = curve.getPoints(100);
    const path = new THREE.BufferGeometry().setFromPoints(points);
    const line = new THREE.LineLoop(path, new THREE.LineBasicMaterial({color:0x00ffff, opacity:0.3, transparent:true}));
    line.rotation.x = Math.PI/2;
    scene.add(line);
  });

  // Étoiles de fond
  const starGeo = new THREE.BufferGeometry();
  const starCount = 2000;
  const starPos = [];
  for(let i=0;i<starCount;i++){
    starPos.push((Math.random()-0.5)*2000, (Math.random()-0.5)*2000, (Math.random()-0.5)*2000);
  }
  starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos,3));
  const starMat = new THREE.PointsMaterial({color:0xffffff, size:1});
  const stars = new THREE.Points(starGeo, starMat);
  scene.add(stars);

  // Animation
  function animate(){
    requestAnimationFrame(animate);
    planets.forEach(p=>{
      p.userData.angle += p.userData.speed;
      p.position.set(
        Math.cos(p.userData.angle)*p.userData.r,
        0,
        Math.sin(p.userData.angle)*p.userData.r
      );
    });
    controls.update();
    renderer.render(scene,camera);
  }
  animate();

  // Resize
  window.addEventListener("resize", ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>
